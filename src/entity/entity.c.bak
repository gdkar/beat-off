#include "entity/entity.h"

attribute *attribute_alloc_(size_t item_size)
{
  attribute *att = calloc(sizeof(attribute),1);
  att->item_size = item_size;
  att->current_fill = 0;
  att->current_size = MIN_DENSE_RESERVATION;
  att->vector       = calloc(att->item_size,att->current_size);
  return att;

}
void attribute_free(attribute *att)
{
  free(att->vector);
  free(att);
}

entity_dense_record *attribute_lookup(attribute *att, entity_id ent)
{
  const uint16_t mask = (MAX_HASHTAB_POPULATION-1);
  uint64_t hash_val = hashfn(ent ^((int64_t)att));
  uint16_t base_val = hash_val & mask;
  uint16_t index = base_val;
  do{
    if(!att->hashtable[index].id) return NULL;
    else if(att->hashtable[index].id==ent) 
      return(entity_dense_record*)( att->vector + (att->item_size*att->hashtable[index].index));
    else
      index = (index+1)&mask;
  }while(index!=base_val);
  return NULL;
}
static entity_hash_record *attribute_lookup_hash(attribute *att, entity_dense_record *rec)
{
  const uint16_t mask = (MAX_HASHTAB_POPULATION-1);
  uint16_t base_val = rec->hash&mask;
  uint16_t index = base_val;
  do{
    if(!att->hashtable[index].id) return NULL;
    else if(att->hashtable[index].id==rec->id) 
      return &att->hashtable[index];
    else
      index = (index+1)&mask;
  }while(index!=base_val);
  return NULL;
}
bool attribute_insert(attribute *att, entity_dense_record *rec)
{
  const uint16_t mask = (MAX_HASHTAB_POPULATION-1);
  uint64_t hash_val = hashfn((rec->id)^((uint64_t)att));
  rec->hash = (uint32_t)hash_val;
  uint16_t base_val = hash_val & mask;
  for(uint16_t offset = 0; offset < MAX_HASHTAB_POPULATION;offset++)
  {
    uint16_t index = (offset+base_val)&mask;
    if(!att->hashtable[index].id){
      att->hashtable[index].id = rec->id;
      att->hashtable[index].offset = offset;
      att->hashtable[index].index  = att->current_fill++;
      if(att->current_size >= att->current_fill){
        att->vector = realloc(att->vector,att->current_size*2*att->item_size);
        att->current_size*=2;
      }
      memmove(att->vector + (att->item_size*att->hashtable[index].index),rec,att->item_size);
      return true;
    }
  }
  return false;
}
bool attribute_erase(attribute *att, entity_id ent)
{
  const uint16_t mask = (MAX_HASHTAB_POPULATION-1);
  uint64_t hash_val = hashfn((ent)^((uint64_t)att));
  uint16_t base_val = hash_val & mask;
  for(uint16_t offset = 0; offset < MAX_HASHTAB_POPULATION;offset++)
  {
    uint16_t index = (offset+base_val)&mask;
    if(!att->hashtable[index].id){
      return false;
    }else if(att->hashtable[index].id==ent){
      uint16_t dense_index = att->hashtable[index].index;
      entity_dense_record *dense_rec = (entity_dense_record*)(att->vector + (att->current_size-1)*att->item_size);
      entity_hash_record  *hash_rec  = attribute_lookup_hash(att,dense_rec);
      hash_rec->index                = dense_index;
      memmove(att->vector + att->item_size*dense_index, dense_rec,att->item_size);
      att->current_size --;
      uint16_t curr = index;
      offset        = 1;
      do{
        index = (curr+offset)&mask;
        if(att->hashtable[index].offset >= offset){
          att->hashtable[curr].id=att->hashtable[index].id;
          att->hashtable[curr].index = att->hashtable[index].index;
          att->hashtable[curr].offset = att->hashtable[index].offset - offset;
          curr   = index;
          offset = 1;
        }else if(!att->hashtable[index].id){
          att->hashtable[curr].id = 0;
          return true;
        }
        offset++;
      }while(1);
    }
  }
  return false;
}
